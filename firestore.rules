/**
 * Core Philosophy: This ruleset enforces a strict user-ownership model. All user-generated content
 * such as their profile, books, wishlist, and swap passes are stored in subcollections under their
 * unique user ID (`/users/{userId}`). Access is strictly limited to the authenticated owner of that data tree.
 * A `superadmin` role is defined, which bypasses most ownership checks for administrative purposes.
 *
 * Data Structure: User-specific data is hierarchically organized under `/users/{userId}`. Shared or
 * transactional data, like `/swaps` and `/libraryTransactions`, are placed in top-level collections.
 * This structural segregation simplifies security rules and improves query performance.
 *
 * Key Security Decisions:
 * - User Listing Restricted: By default, users cannot list all other users. This is overridden for `superadmin`.
 * - Private Data Isolation: Top-level collections like `/swaps` and `/libraryTransactions` that contain
 *   sensitive data shared between specific users are not listable, except by a `superadmin`. Individual documents
 *   can only be accessed by authorized participants.
 * - Path-Based Security: For all data under `/users/{userId}`, authorization is primarily determined
 *   by matching the `userId` in the path with the requester's authenticated UID, or by being a `superadmin`.
 *
 * Denormalization for Authorization: To ensure performant and secure access control, this ruleset
 * relies on denormalized data. Most critically, documents in the `/swaps` collection MUST contain
 * the UIDs of all participants (e.g., `bookOwnerId`, `wishlistOwnerId`). This avoids slow and costly
 * cross-collection `get()` calls during rule evaluation and is essential for securing swap data.
 *
 * Structural Segregation: User data is kept in private subcollections (`/users/{userId}/books`),
 * which is more secure and performant for listing a user's own items than a single global collection
 * with a 'userId' field.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // ------------------------------------------------------------------------
    // Helper Functions
    // ------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }
    
    /**
     * Checks if the current user has the 'superadmin' role.
     * This relies on a 'role' field in the user's profile document.
     */
    function isSuperAdmin() {
      return isSignedIn() && get(/databases/$(database)/documents/users/$(request.auth.uid)).data.role == 'superadmin';
    }

    /**
     * Checks if the authenticated user's ID matches the provided userId.
     * This is the core of the user-ownership model.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * A more robust check for update/delete operations, ensuring the document
     * exists before attempting to modify it and that the user is the owner.
     * Superadmins can also perform these operations.
     */
    function isExistingOwnerOrAdmin(userId) {
      return (isOwner(userId) && resource != null) || isSuperAdmin();
    }

    /**
     * Validates that the document being created has an 'id' field that
     * matches the document's ID, which is the user's UID.
     * Enforces consistency for a user's root profile document.
     */
    function isCreatingOwnProfile(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * Validates that a document being created in a user's subcollection
     * has a 'userId' field that correctly points back to the parent user.
     * Enforces relational integrity.
     */
    function isCreatingOwnSubdocument(userId) {
      return request.resource.data.userId == userId;
    }

    /**
     * Enforces immutability for critical relational ID fields during an update,
     * preventing re-assignment of ownership. Superadmins can bypass this.
     */
    function isUserIdImmutable() {
      return request.resource.data.userId == resource.data.userId || isSuperAdmin();
    }

    /**
     * Enforces immutability for the root user profile's 'id' field.
     * Superadmins can bypass this.
     */
    function isProfileIdImmutable() {
      return request.resource.data.id == resource.data.id || isSuperAdmin();
    }


    /**
     * @description Rules for user profile documents.
     * @path /users/{userId}
     * @allow A user can get/update their own profile. A superadmin can get/update any profile.
     * @deny A regular user cannot get/delete another user's profile.
     * @allow A superadmin can list all users.
     * @principle Restricts access to user profiles, with an override for administrators.
     */
    match /users/{userId} {
      allow get, update, delete: if isOwner(userId) || isSuperAdmin();
      allow list: if isSuperAdmin();
      allow create: if isOwner(userId) && isCreatingOwnProfile(userId);
    }

    /**
     * @description Rules for a user's collection of books.
     * @path /users/{userId}/books/{bookId}
     * @allow A user can manage books in their own collection. A superadmin can manage any book.
     * @deny A regular user cannot access books in another user's collection.
     * @principle Enforces data ownership with an admin override.
     */
    match /users/{userId}/books/{bookId} {
      allow read, write: if isOwner(userId) || isSuperAdmin();
      allow create: if (isOwner(userId) && isCreatingOwnSubdocument(userId)) || isSuperAdmin();
    }

    /**
     * @description Rules for a user's personal wishlist.
     * @path /users/{userId}/wishlist/{wishlistItemId}
     * @allow A user can manage their own wishlist. A superadmin can manage any wishlist.
     * @deny A regular user cannot access another user's wishlist.
     * @principle Secures private wishlists with an admin override.
     */
    match /users/{userId}/wishlist/{wishlistItemId} {
      allow read, write: if isOwner(userId) || isSuperAdmin();
       allow create: if (isOwner(userId) && isCreatingOwnSubdocument(userId)) || isSuperAdmin();
    }

    /**
     * @description Rules for a user's swap pass subscriptions.
     * @path /users/{userId}/swapPasses/{swapPassId}
     * @allow A user can manage their own swap passes. A superadmin can manage any swap pass.
     * @deny A regular user cannot access another user's swap passes.
     * @principle Protects sensitive subscription data with an admin override.
     */
    match /users/{userId}/swapPasses/{swapPassId} {
      allow read, write: if isOwner(userId) || isSuperAdmin();
       allow create: if (isOwner(userId) && isCreatingOwnSubdocument(userId)) || isSuperAdmin();
    }

    /**
     * @description Rules for swap transaction documents.
     * @path /swaps/{swapId}
     * @allow A participant can read/update their swap. A superadmin has full access.
     * @deny Anonymous or non-participant access is denied. The collection is not listable for regular users.
     * @principle Enforces shared access for collaborators and full access for admins.
     */
    match /swaps/{swapId} {
      allow get, update, delete: if (isSignedIn() && (request.auth.uid == resource.data.bookOwnerId || request.auth.uid == resource.data.wishlistOwnerId)) || isSuperAdmin();
      allow list: if isSuperAdmin();
      allow create: if (isSignedIn() && request.resource.data.wishlistOwnerId == request.auth.uid) || isSuperAdmin();
    }

    /**
     * @description Rules for transaction records for library partners.
     * @path /libraryTransactions/{libraryTransactionId}
     * @allow A library owner can manage their own transactions. A superadmin has full access.
     * @deny A library owner cannot access another library's transactions. Collection is not listable for regular users.
     * @principle Secures business-sensitive data with an admin override.
     */
    match /libraryTransactions/{libraryTransactionId} {
      allow read, write: if (isSignedIn() && resource.data.libraryId == request.auth.uid) || isSuperAdmin();
      allow list: if isSuperAdmin();
      allow create: if (isSignedIn() && request.resource.data.libraryId == request.auth.uid) || isSuperAdmin();
    }
  }
}
