
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function getUserData(userId) {
      return get(/databases/$(database)/documents/users/$(userId)).data;
    }

    function isRole(userId, role) {
      return getUserData(userId).role == role;
    }
    
    function isOneOfRoles(userId, roles) {
      return getUserData(userId).role in roles;
    }

    function isIntermediaryOfLocation(locationId) {
      let userData = getUserData(request.auth.uid);
      return userData.role == 'intermediary' && userData.locationId == locationId;
    }
    
    function serverTimestampOrUnchanged(fieldName) {
      return request.resource.data[fieldName] == request.time || request.resource.data[fieldName] == resource.data[fieldName];
    }
    
    // --- Collection Rules ---

    // Users: Can only write to their own doc, and only specific fields.
    match /users/{userId} {
      allow read: if isSignedIn();
      allow create: if isOwner(userId);
      allow update: if isOwner(userId) && request.resource.data.keys().hasOnly(['profile', 'updatedAt']);
      allow delete: if isRole(request.auth.uid, 'admin');
    }

    // Cities: Public read-only dataset.
    match /cities/{cityId} {
      allow get, list: if true;
      allow write: if false; // Managed by admin/backend process
    }
    
    // Locations: Publicly readable, but writing is restricted.
    match /locations/{locationId} {
      allow get: if resource.data.status == 'active';
      allow list: if true;

      // Intermediary can edit some details, but not critical fields.
      allow update: if isIntermediaryOfLocation(locationId)
                    && request.resource.data.keys().hasOnly(['name', 'address', 'updatedAt'])
                    && serverTimestampOrUnchanged('updatedAt');
      
      // Admin has full control.
      allow create, update: if isRole(request.auth.uid, 'admin');
      allow delete: if isRole(request.auth.uid, 'admin');

      // Crucially, geohash cannot be written by clients.
      deny write: if 'geohash' in request.resource.data.diff(resource.data).affectedKeys();
    }

    // Books: Owner can create/update/delete. Others can read.
    match /books/{bookId} {
        allow read: if true;
        allow create: if isOwner(request.resource.data.ownerId) && serverTimestampOrUnchanged('createdAt');
        allow update: if isOwner(resource.data.ownerId) 
                      && serverTimestampOrUnchanged('updatedAt')
                      && !('ownerId' in request.resource.data.diff(resource.data).affectedKeys());
        allow delete: if isOwner(resource.data.ownerId);
    }

    // Swaps: The core of the server-authoritative logic.
    match /swaps/{swapId} {
      allow get: if request.auth.uid in resource.data.participantIds || isIntermediaryOfLocation(resource.data.locationId);
      allow list: if isSignedIn(); // Queries must be secured with 'where' clauses.

      // CREATE: Only a requester can initiate a swap.
      allow create: if isSignedIn()
                    && request.auth.uid == request.resource.data.requesterId
                    && request.resource.data.status == 'requested'
                    && request.resource.data.requesterId in request.resource.data.participantIds
                    && request.resource.data.ownerId in request.resource.data.participantIds
                    && request.resource.data.size() == 9; // Enforce minimal fields on create
      
      // UPDATE: State machine logic.
      allow update: if isSignedIn() && request.auth.uid in resource.data.participantIds
                    && serverTimestampOrUnchanged('updatedAt')
                    // Transition: owner accepts a request
                    && resource.data.status == 'requested' 
                    && request.resource.data.status == 'accepted' 
                    && request.auth.uid == resource.data.ownerId
                    // Transition: requester cancels a pending request
                    && resource.data.status == 'requested' 
                    && request.resource.data.status == 'cancelled'
                    && request.auth.uid == resource.data.requesterId
                    // Transition: any participant cancels an accepted swap
                    && resource.data.status == 'accepted' 
                    && request.resource.data.status == 'cancelled';

      // Only an intermediary can confirm the swap. This should ideally be a Cloud Function.
      // This rule is a placeholder for that server-side logic.
      allow update: if isIntermediaryOfLocation(resource.data.locationId)
                    && resource.data.status == 'accepted'
                    && request.resource.data.status == 'confirmed'
                    && request.resource.data.confirmedBy == request.auth.uid;
    }
    
    // Default deny all other collections.
    match /{path=**} {
      allow read, write: if false;
    }
  }
}

    